---
layout: post
title:  "git한테 암바 걸렸을 때 탈출하는법"
categories: 실습
date: 2025-12-13 11:20:18 +0900
tags: AI uv  
mathjax: True
author: Haribo
---
* content
{:toc}

누구나 한번 쯤 merge, rebase, pull 하다가 git한테 백초크 잡혀서 가진거 다 뺏기고 remote 햄 커밋부터 다시 시작한적 있을것이다.    
나 또한 최근 이 개새끼한테 잡혀서 머리채 다 뜯기고 겨우 탈출할 수 있었는데, 걍 pull-merge-push 만 쳐하던 과거의 나와 풀스파링 뜨고싶은 심정이었다.  

  
AI 학습을 위해서 값비싼 장비가 필요하며 임대기간은 한정적이며 매우 짧다. 학습코드를 개씹완벽하게 짜서 걍 손빨기만 하면 되는 상황이 아니라면 우리는 학습을 돌리며 끊임없이 수정하고, 마이그레이션하고 서커스하고 해야한다. 
* 안그러면 나보다 연봉더 높은 GPU를 놀게 해야한다. 차라리 내가 노는게 낫지 GPU는 절대 놀게 두면 안된다...

---

**시간이 촉박한 상황에서** 팀원들이 동일 출발지인 `main`부터 새로 브랜치 파서 작업하다 합쳐나갈 때, 문제는 이 때 발생한다  

* 각각의 task 는 우선순위도 다르며, 난이도도 다르며, 각자의 코딩 실력(속도)도 다르다.
  * 내작업은 쉬운데 오래걸리고 검증이 중요함, 다른애 작업은 어렵지만 빨리 끝낼수있고 등등
* 검증이 중요한 내 작업에 `main` 기준으로 짜다가 다른애가 완성을 먼저 했다면...
  * 근데 문제는 디버그 한다고 소스코드 외에 존나 긴 config 파일, test case, 추가한 dummy 파일등을 수정/생성한 상황에서 그거 빼고 코드 부분만 먼저 합쳐서 push 해야한다던가 등등






# 0. git 내부 사알짝
gemini쿤이 설명을 너무 고봉밥으로 해줘서 핵심만 짚어본다.  
문뜪 든 생각인데, 프로젝트 안에 코드 약간 바꾼것들 다 기록해두고 글로 갈 수 있고 그런거 생각해보면 도대체 어떻게 파일관리를 하는지 신기하긴했었음. 그거에 대한 맛을 살짝 볼껀데,,,  

  
git은 어떤 파일 시스템이 아니라 'key-value' 데이터 시스템이다.  
아무 git 프로젝트루트로 가서 `lf -Fl .git`을 때려보자. 그러면 아래와같은 형식이 나오는데 `objects` 안에 중요한게 저장됨.
```shell
.git/
├── HEAD         # 현재 Checkout된 브랜치를 가리키는 포인터
├── config       # 설정 파일
├── description
├── hooks/       # 훅 스크립트 
├── index        # Staging Area (바이너리 파일)
├── objects/     # ★ 모든 데이터(컨텐츠)가 저장되는 DB
└── refs/        # * 브랜치, 태그 등의 포인터 저장소
```

git은 모든 폴더명, 파일명, (파일안에)내용물 전~~부 40자짜리 hash 로 매핑한다음에 관리함. 
* `SHA-1 (Secure Hash Algorithm 1)` 으로 어떤 내용이든 40글자짜리 로 매핑해보림.

```
echo '이건 어떤 파일안애 코드들임' | git hash-object --stdin
70f87608c4a738b3ef128377a2444a3c366dfb04

echo '이건 어떤 파일안애 코드들임' | git hash-object --stdin
9b1ce651b639d0ce33c2c18244d5d7c7e5d844dd
```
  
그 어떤거든 일단 hash로 바꿔놓고 그걸 파일명으로 해서 그 안에 바이너리화된 컨텐츠를 집어넣는다. `objects` 안에 들어가서 파일들을 한번 쭉보면 `00` ~ `ff` 폴더안에 여러 hash값들이 들어있는걸 볼 수 있는데 그중 하나 까보면 이진화된 컨텐츠들이 들어있음.
* hash로 바꾸고 앞 `2`자는 폴더명, 그뒤에 `38`자는 파일명
* 까보면 안에 이진화 된 컨텐츠.

```shell
objects % tree .
.
├── 00
│   ├── 7f59616d1216e34abc1684d3c4b62cf4a2dcda
│   └── b7b7f5a6b9a0e0cb1979fc06ec7ec8649d3033
├── 01
│   └── 11ef6072b688ec0c290f8454656037b41bc30b
├── 03
│   └── 89f46c85e52de3f3cfd1666097add72f8097d5
├── 04
│   └── d7773bc6f4333a07bbc9ff5f66ed95f2f5a002
├── 05
│   └── ff7382984d6bfa1a2f9ce04cf7f1a29842c867
```

이런식으로 저장 하기 때문에 내가  `a.py`, `b.py`, `c.py` ~~ 100만개 파일 만들어놓고 안에 동일한 내용 박아놔도 컨텐츠 파일은 한개만 유지됨.  
* Filename (12aedf...): 이 객체의 ID (Key).
* File Content: 이 객체의 실제 데이터 (Value). `import torch...` 같은 코드 내용이 zlib으로 눌려있음.

이렇게 한 프로젝트에 있는 모든 폴더, 파일, 컨텐츠를 hash로 만들어둘 수 있고, 프로젝트 내에 모든 파일명, 권한, hash 를 다 모아서 다시한번 `SHA-1` 돌려서 root에 대한 hash 값을 얻을 수 있다고 함.  
만약 내가 파일명을 쪼금 바꾸거나, 콘텐츠 안에 글자 하나만 수정해도 root 의 hash값이 달라져버리는거임.  

```
# 1. 가장 최근 커밋의 해시 확인
git log -1 --pretty=format:%H
> 7bf4b5488...

# 2. 그 커밋 객체의 내용물 뜯어보기
git cat-file -p 7bf4b5488...
> tree acdac7e527...
> parent a5d587ef54...
> author gkalstn000 ...
> committer gkalstn000 ...

# 3. 그 커밋이 가리키는 Tree 뜯어보기
$ git cat-file -p acdac7e527...
> 100644 blob  3e7bcd0d0c...    run.py
> 100644 blob  65f903b238...    requirements.txt

# 4. 소스코드(Blob) 내용 확인
$ git cat-file -p 3e7bcd0d0c... 
> import torch
> ...
```

