---
layout: post
title:  "다음 큰 숫자"
categories: 프로그래머스
date:   2021-01-20 11:40:18 +0800
tags: Lv.2
author: Haribo
---

* content
{:toc}
# 다음 큰 숫자

```python
def solution(n = 78):
    b = bin(n)[2:]
    index = b.rfind('01')
    if index != -1 :
        b = b[:index] +'10' +''.join(b[index+2:][::-1])
    else :
        b = b[0]+'0'+ ''.join(b[1:][::-1])
    return int(b, 2)
```

---









## 풀이

반복문 돌려서 풀면 당연히 시간초과 뜰거라 예상하고 패턴 찾느라 고생좀 했는데 그냥 반복문 돌려서 다음 큰 숫자 찾아도 되는 문제였습니다. 그래서 효율성이나 시간은 가장빠른 알고리즘이 나오게되긴 했습니다만, `1~20` 까지 숫자를 `2진법`으로 바꿔보겠습니다.

```
1 -> 1
2 -> 10
3 -> 11
4 -> 100
5 -> 101
6 -> 110
7 -> 111
8 -> 1000
9 -> 1001
10 -> 1010
11 -> 1011
12 -> 1100
13 -> 1101
14 -> 1110
15 -> 1111
16 -> 10000
17 -> 10001
18 -> 10010
19 -> 10011
20 -> 10100
```

그렇다면 각각의 숫자들의 다음큰 수와 비교해 봅시다

```
1 | 10
10 | 100
11 | 101
100 | 1000
101 | 110
110 | 1001
111 | 1011
1000 | 10000
1001 | 1010
1010 | 1100
1011 | 1101
1100 | 10001
1101 | 1110
1110 | 10011
1111 | 10111
10000 | 100000
10001 | 10010
10010 | 10100
10011 | 10101
10100 | 11000
1001110 | 1010011 (78, 83)
```

이진수의 패턴은 2가지로 볼 수 있습니다.

> case1 : `1`이 연속적으로 나옴 ex) 1111000, 1111, 10000
>
> case2 : `1` 사이에 `0`이 있음 ex) 100001, 1110010, 10010010

case1 의 경우엔 제일앞의 `1`뒤에 `0`을 붙이고 그 나머지 숫자는 뒤집습니다.

```
10000 -> 100000
111 -> 1011
1110 -> 10011
```

![](/images/nextbignum/case1.gif) 

case2의 경우엔 제일 오른쪽 `01`을 뒤집고 그 뒤에 숫자들을 뒤집습니다.

```
10001 - > 10010
110010 -> 110100
1001110 -> 1010011
```

![](/images/nextbignum/case2.gif) 

끝.

```python
def solution(n = 78):
    b = bin(n)[2:]
    index = b.rfind('01')
    if index != -1 :
        b = b[:index] +'10' +''.join(b[index+2:][::-1])
    else :
        b = b[0]+'0'+ ''.join(b[1:][::-1])
    return int(b, 2)
```