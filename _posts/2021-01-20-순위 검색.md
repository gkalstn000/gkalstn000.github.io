---
layout: post
title:  "순위 검색"
categories: 프로그래머스 2021_KAKAO_BLIND_RECRUITMENT
date:   2021-01-20 11:40:18 +0800
tags: Lv.2 Tree
mathjax: true
author: Haribo
---

* content
{:toc}
# 순위 검색

## 해설 버전

[2021 카카오 신입공채 1차 온라인 코딩 테스트 for Tech developers 문제해설](https://tech.kakao.com/2021/01/25/2021-kakao-recruitment-round-1/){: target="_blank"}

```python
from collections import defaultdict
from bisect import insort, bisect_left
def solution(info, query):
    answer = []
    table = [x.split(' ') for x in info]
    queries = [x.replace('and ', '') for x in query]
    masks = [bin(x)[2:].zfill(4) for x in range(16)]
    group = defaultdict(list)

    for row in table :
        score = int(row.pop())
        for i, mask in enumerate(masks) :
            insort(group[' '.join([att if m == '1' else  '-' for m, att in zip(mask, row)])], score)
    for q in queries :
        index = q.rfind(' ')
        score = int(q[index+1: ])
        scores = group[q[:index]]
        if not scores :
            answer.append(0)
            continue
        answer.append(len(scores) - bisect_left(scores, score))
    return answer
```

---









### group

일단 4개의 변수

```
table : 지원자 정보 table
queries : 질의 형식
masks : query mask
group : query mask 그룹
```

을 정의합니다. 그룹`key`를 만들껀데 `table` 행 하나당 16개씩 만들겁니다.

![그룹](/images/ranking/grouping.png)

지원자 종류는 24가지가 나올 수 있고, 종류 하나당 16개씩, 최대 $$24 \times 16$$개의 그룹이 만들어질 수 있습니다. 그리고 각 `row`의 점수를 삽입해주면 그룹 테이블이 완성됩니다. **대신 `score` 삽입 시 그냥 삽입하면 안되고 크기를 유지하며 삽입 해야 합니다.**  그 역할을 해주는게 바로 `bisect` 라이브러리입니다. [bisect 공식 문서](https://docs.python.org/ko/3/library/bisect.html){: traget="_blank"} 참조하십쇼

![그룹](/images/ranking/grouping2.png)

```python
for row in table :
    score = int(row.pop())
    for i, mask in enumerate(masks) :
        insort(group[' '.join([att if m == '1' else  '-' for m, att in zip(mask, row)])], score)
```

---

### query 

그룹을 다 만들었다면 `query`를 통해 조건에 맞는 지원자 수를 세는건 쉽습니다. `query`에서 `score`를 분리 해준 후 그룹의 `value` 에서 `socre` 이상 점수의 개수를 반환하면 됩니다. **대신 `socre`이상되는 점수를 찾을 때 또한 `bisect`를 이용해야합니다.** 

```python
from collections import defaultdict
from bisect import insort, bisect_left
def solution(info, query):
    answer = []
    table = [x.split(' ') for x in info]
    queries = [x.replace('and ', '') for x in query]
    masks = [bin(x)[2:].zfill(4) for x in range(16)]
    group = defaultdict(list)

    for row in table :
        score = int(row.pop())
        for i, mask in enumerate(masks) :
            insort(group[' '.join([att if m == '1' else  '-' for m, att in zip(mask, row)])], score)
    for q in queries :
        index = q.rfind(' ')
        score = int(q[index+1: ])
        scores = group[q[:index]]
        if not scores :
            answer.append(0)
            continue
        answer.append(len(scores) - bisect_left(scores, score))
    return answer
```



---

## 트라이 노드버전

트라이 노드로는 못푼다고들 했었지만 아무리 생각해도 [가사검색](https://gkalstn000.github.io/2020/11/26/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%80%EC%82%AC-%EA%B2%80%EC%83%89/){: target="_blank"}이랑 똑같은 문제같은데 이상하게 효율성에서 막혀서 고민하다가 `bisect`라는 라이브러리를 알게 되었고 바로 풀렸다...

트라이 노드 버전은 **트라이 트리를 16개(`mask`갯수만큼) 만들어** `query`하는건데 해설버전보다 아주조금 느리지만 훨씬 간결한 장점이 있다.

코드설명은...ptt로 보내드렸습니다 매일확인해주세요

```python
from bisect import insort, bisect_left
def solution(info, query):
    answer = []
    table = [x.split(' ') for x in info]
    queries = [x.replace('and ', '').split(' ') for x in query]
    trees = [Trie() for _ in range(16)]
    masks = [bin(x)[2:].zfill(4)+'1' for x in range(16)]
    for i, mask in enumerate(masks) :
        for j in table :
            trees[i].insert([t for m, t in zip(mask, j) if m != '0'])
    for j in queries :
        index = ''.join(['0' if x == '-' else '1' for x in j[:-1]])
        answer.append(trees[int(index, 2)].query(j))
    return answer
  
  
class TrieNode:
    def __init__(self, factor):
        self.factor = factor
        self.children = {}
        self.score = []

class Trie(object):
    def __init__(self):
        self.root = TrieNode("")

    def insert(self, info):
        score = info.pop()
        node = self.root
        for factor in info:
            if factor not in node.children:
                node.children[factor] = TrieNode(factor)
            node = node.children[factor]
        insort(node.score, int(score))
    def query(self, query_form) :
        score = query_form.pop()
        node = self.root
        for factor in query_form :
            if factor == '-' : continue
            if factor not in node.children : return 0
            node = node.children[factor]
        return len(node.score) - bisect_left(node.score, int(score))
```

