---
layout: post
title:  "문자열의 아름다움"
categories: 프로그래머스 월간_코드_챌린지_시즌1
date: 2021-03-20 15:06:18 +0900
tags: Lv.5
mathjax: true
author: Haribo
---

* content
{:toc}
[teferi풀이 원문](http://www.teferi.net/ps/problems/programmers/68938#comment_5c0b5b3432fcc27ca4b02fd2aa29ebc9)

```python
from collections import defaultdict
from itertools import groupby
def solution(s):
    char_seq_count = defaultdict(lambda: defaultdict(int))
    for char, group in groupby(s):
        char_seq_count[char][len(list(group))] += 1
    answer = ((n := len(s)) - 1) * n * (n + 1) // 6
    for char_seq in char_seq_count.values():
        t = sum(char_seq.values())
        s = sum(l * count for l, count in char_seq.items())
        for l in range(1, max(char_seq) + 1):
            answer -= s * (s - 1) // 2
            s -= t
            t -= char_seq[l]
    return answer
```









## 알고리즘

> `s`의 모든 `sub_string`들의 길이의 합을 구한다
>
> 모든 `sub_string` 거리의 합에서 **양끝이 동일한 문자의 반복이라면 반복문자의 개수만큼 빼준다**
>
> * ex) `zzabczz` 라면 `-2`를 해준다.

### 최대 아름다움 거리

> `s`의 모든 문자가 전부 다르다고 가정하면
>
> ```
> n = len(s)
> ```
>
> 모든 `len(sub_s)`의 합
>
> ![](/images/beauty/sub.png)

### 아름다워지기

> ```
> s = zzabcdezz
> ```
>
> `s`의 길이는 `9`이다. 양끝에 연속되는 단어의 길이만큼 빼주면 아름다움 거리가 나온다.
>
> ```
> beauty(s) = len(s) - 반복되는단어개수(2)
> ```

전체 `sub_string`들의 길이의 합을 구했기 때문에, 모든 양끝이 연속되는 문자들의 조합의 경우의 수들만 제거해주면 된다.

### 양끝이 연속되는 문자의 경우의 수

어떤 문자열에서 `a`가 나오는 위치가 이렇다고 가정하자

```
aaa_aa_aa_a_a_a_a
```

> `comb_a[i]` :  `'a'*i`를 뽑을 수 있는 개수
>
> `char_seq = {3 : 1, 2 : 2, 1 : 4}` 로 둔다면, `'a'*i`개의 덩어리를 세야하기 때문에
>
> * `comb_a[1] = 3*1 + 2*2 + 1*4`, 조합 경우의수는 `comb(comb_a[1], 2)`
> * `comb_a[2] = (3-1)*1 + (2-1)*2 + (1-1)*4`, 조합 경우의수는 `comb(comb_a[2], 2)`
> * `comb_a[3] = (3-2)*1 + (2-2)*2`, 조합 경우의수는 `comb(comb_a[3], 2)`
>
> 이를 점화식으로 바꾸면
>
> `t[i] = sum(char_seq.values())`
>
> `comb_a[i] = comb_a[i-1]-t[i]`
>
> `t[i] -= char_seq[i]`

```python
from collections import defaultdict
from itertools import groupby
def solution(s):
    char_seq_count = defaultdict(lambda: defaultdict(int))
    for char, group in groupby(s): # 알파벳별 덩어리 count
        char_seq_count[char][len(list(group))] += 1
    answer = ((n := len(s)) - 1) * n * (n + 1) // 6 # 전체 sub_string 길이
    for char_seq in char_seq_count.values(): #각 알파벳에대해서 연속된 알파벳경우의수 빼주기
        t = sum(char_seq.values())
        s = sum(l * count for l, count in char_seq.items())
        for l in range(1, max(char_seq) + 1):
            answer -= s * (s - 1) // 2
            s -= t
            t -= char_seq[l]
    return answer
```

