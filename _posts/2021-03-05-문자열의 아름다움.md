---
layout: post
title:  "문자열의 아름다움"
categories: 프로그래머스 월간_코드_챌린지_시즌1
date: 2021-03-05 15:06:18 +0900
tags: Lv.5
mathjax: true
author: Haribo
---

* content
{:toc}
[teferi풀이 원문](http://www.teferi.net/ps/problems/programmers/68938#comment_5c0b5b3432fcc27ca4b02fd2aa29ebc9)

```python
from collections import defaultdict
from itertools import groupby
def solution(s):
    char_seq_count = defaultdict(lambda: defaultdict(int))
    for char, group in groupby(s):
        char_seq_count[char][len(list(group))] += 1
    unpretty = ((n := len(s)) - 1) * n * (n + 1) // 6
    for char_seq in char_seq_count.values():
        t = sum(char_seq.values())
        s = sum(l * count for l, count in char_seq.items())
        for l in range(1, max(char_seq) + 1):
            unpretty -= s * (s - 1) // 2
            s -= t
            t -= char_seq[l]
    return unpretty
```









## 알고리즘

> `unpretty(s) = len(s) - 1`
>
> `pretty(s) = unpretty(s) - (양끝)같은문자반복갯수`
>
> * `pretty(zzabcdzz) = 7 - 2`
> * `pretty(zzzabz) = 5 - 1`
>
> $\sum pretty(s_{sub}) = \sum unpretty(s_{sub}) - \sum Lump(s_{sub})$

## $unpretty$

문자열 `s`가 모두 다른 알파벳으로 구성되어있다고 가정했을 때의, 최대 아름다움 길이다. `s`의 모든 부분 문자열들의 $unpretty$ 값을 구해준 뒤, 덩어리들의 갯수들만 빼주면 된다.

![](/images/pretty/unpretty.png)

```python
unpretty = (n-1) * n * (n+1) / 6
```

## $Lump$

문자열 `s` 내에서 알파벳`a`의 분포가 이렇게 되있을 때

```
aaaa__aaa_____a__aa__aaa
```

덩어리 `a`들을 이렇게 정의할 수 있다.

```python
lump['a'] = {4 : 1,
             3 : 2,
             2 : 1,
             1 : 1}
```

양끝이 `a`인 경우는