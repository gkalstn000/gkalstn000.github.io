---
title: 제어자
tags: [Java]
keywords:
last_updated: July 28, 2020
summary: "무심코 지나쳤던 제어자의 종류와 기능 조합에대해 알아보겠다."
sidebar: programming_sidebar
permalink: modifier.html
folder: programming
---

# 제어자

접근제어자 : public, protected, default, private

그 외 : static, final, abstract, synchronized ...



## 기타 제어자

### static

사용가능 : 멤버변수, 메서드, 초기화 블럭  

static 초기화 블럭은 주로 static 변수 초기화 하는데 사용된다.

### final

사용가능 : 클래스, 메서드, 멤버변수, 지역변수  

변경 불가, 오버라이딩 불가, 조상이 될수 없음(확장 불가)  

final 인스턴스 변수는 생성자에서 초기화 할 수 있다. <- 인스턴스마다 final 변수의 값이 다르게 할 수 있음.  

요약하면 Immutable/Read-only를 설정하고 싶을때 final 을 지정한다. 딱히 성능적인 이점은 없는것 같다. 하지만 가독성 측면에서 조금더 눈에띄게 할 수 있다.  

팀프로젝트를 할 경우엔 final은 합의를 한 후 사용하는것이 좋을듯 하다.

### abstract

사용가능 : 클래스, 메서드  

인스턴스 생성 불가  

코딩을 할때 매우 편리해짐. abstract class의 경우 필요한 메서드를 정리해 놓고, 상속을 통해 구현해 나갈때 빼먹은 메서드를 알려주기 때문에 코드가독성, 디렉토리안의 상속구조 가독성도 매우 좋아짐.



## 접근 제어자

외부에서 접근을 제어해줌.  

Private : 같은 클래스내에서만 접근 가능  

Default : 같은 패키지 내에서 접근 가능  

Protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근 가능(상속된 자손클래스는 접근 가능)  

public : 제한 없음  

public > protected > default > private.

접근 제어자를 선언하는 이유는 내부에 선언된 데이터를 보호하기 위함이다.  

데이터를 감춤(캡슐화)  

디버깅 할때 또한 내가 체크해야할 범위를 알 수 있게된다.  



### 생성자에서 접근제어자

외부에서 인스턴스생성을 제한하는 방법.  

생성자 앞에 private를 붙여서 외부에서 이 클래스의 인스턴스 생성을 막는 대신 public static getInstance()메서드를 생성하여 외부에서도 인스턴스 생성을 가능하게 만든다.  

이 방법을 사용할 땐 static을 적절히 섞어주어야함

```java
class Example {
  private static Example ex = new Example(); // getInstane() 메서드를 외부에서 호출할때를 대비해(인스터스 생성이 불가능하므로 인스턴스변수를 넘겨줄수가없음) static instance를 미리 만들어 놓는다.
  private Example(){} // 생성자
  public static Example getInstance() {
    //이 메서드를 통해 어디에서나 ex를 가져갈 수 있도록 해주고, static이 붙은 이유 인스턴스 생성을 못하므로 static method만 사용가능하기 때문이다.
    return ex;
  }
}
```

### 제어자의 조합

클래스 : public, default, final, abstract  

메서드 : 모든 접근제어자, final, abstract, static  

멤버변수 : 모든 접근제어자, final, static  

지역변수 : final  

팁

* 상속이 예상된다? -> protected
* 접근 금지 -> private
